# 数组

## 1. two sum 两数之和

给定一个整数数组和一个目标值，找出数组中和为目标值的**两个**数。

### 暴力双重遍历

要查找和为某个值的两个数，第一反应应该是暴力的双重遍历，两两求和即可。效率低：O(N^2)

### 使用哈希表

本质：查找指定的值是否在数组中，若存在则取出索引 => **哈希表**

当遍历取到数组中的一个数 x 时，只需判断 `target - x` 是否也存在数组中，若存在则取出索引值。哈希表取值复杂度为 O(1) ，遍历后总复杂度为 O(N)

需注意去重，如 `[3, 3]` 在搜索 3 时需加不等条件去掉。



## 4. median of two sorted arrays 两个排序数组的中位数

给定两个大小为 m 和 n 的有序数组 **nums1** 和 **nums2**，请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 

### 合并后查找中位数

合并两个有序数组，可以 append 后 sort，也可以直接 merge，最后取中位数即可。效率低：O(NlogN) 或 O(logN)

### 使用二分查找

联系有序数组的二分查找复杂度为 O(logN)，本题的立意也在此。题目本质：找出两个数组中第 K 大的数

```go
func findKth(nums1, nums2 []int, k int) {
    // TODO
}
```



## 11. container with most water 盛最多水的容器

给定 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

### 暴力双重遍历

取出所有区域的组合，宽（横轴差）* 高（纵轴最小值）= 面积，逐个比较并取 maxArea，复杂度：O(N^2)

### 双指针法

使用 2 个指针分别指向数组的首尾，短指针向长指针移动，逐个求面积并比较取 maxArea

依据：向长指针方向移动 1 格，虽然二者之间的宽度 - 1，但高度至少+1，总体面积不变或在增加。

**<u>解法+1</u>**：双指针能减少一个维度的数组遍历，在 15 16 题中体现明显，比如三重遍历可化为双重遍历 + 一层双指针



## 15. 3sum 三数之和

给定一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？找出所有满足条件且不重复的三元组。

这个题和 two sum 不太一样，不过也可实现，遍历数组两两求和得 sumArr，再次遍历数组，看元素的相反数是否在该和数组中，在就取出

### 双指针法

先将数组排序方便取值，遍历数组，取 `head = i+1` 和 `tail = len(arr)-1` 两个首尾位置，对 head 和 tail 上的值求和，再分情况讨论：和比 `-a` 小则 `head++` 向后移取更大的值，和比 `-a` 大则 `tail—` 向前移，相等则找到了三元组。

注意双指针法是怎么去重的：由于数组有序，直接跳过相同元素

- 数组中连续的元素直接跳过：`nums[i] == nums[i-1]` 

- 找到一个三元组并继续移动时，跳过相同元素：

  ```go
  case sum == remain: // 找到三元组
      res = append(res, []int{nums[i], nums[head], nums[tail]})
      for head < tail && nums[head] == nums[head+1] { // 剔除待选数字中连续相等的数
          head++
      }
      for head < tail && nums[tail] == nums[tail-1] {
          tail--
      }
      head++
      tail--
  ```


## 16. 3sum closest 最接近的三数之和

给定一个包括 *n* 个整数的数组 `nums` 和 一个目标值 `target`。找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。

解法与 15 题类似。

### 双指针法

**最接近**即要取绝对值。取 head 和 tail 两个索引指针，三数求和后取新的 `abs(sum - target)`，并判断 sum 是否为最接近的和。注意双指针的移动方向与 15 题类似，都是值小 head 后移，值大 tail 前移。双指针法的移动前提是数组有序。

